ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
plot_tree
attach(sequence_data)
lineage_info<-lineage_info[order(lineage_info$lineage),]
#Making a nice tree with tips colours according to lineage, outlined in grey for aesthetics
plot_tree<-ggtree::ggtree(tree, colour = "grey50", ladderize = T) %<+% sequence_data +
ggtree::geom_tippoint(color="grey50", size=4)+
ggtree::geom_tiplab()+
ggtree::geom_tippoint(ggplot2::aes(color=lineage), size=3)  +
ggtree::theme(plot.title = ggplot2::element_text(size = 40, face = "bold"))+
ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
plot_tree
#Making a nice tree with tips colours according to lineage, outlined in grey for aesthetics
plot_tree<-ggtree::ggtree(tree, colour = "grey50", ladderize = T) %<+% sequence_data +
ggtree::geom_tippoint(color="grey50", size=4)+
ggtree::geom_tiplab(geom = "text")+
ggtree::geom_tippoint(ggplot2::aes(color=lineage), size=3)  +
ggtree::theme(plot.title = ggplot2::element_text(size = 40, face = "bold"))+
ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
plot_tree
rm(list=ls())
setwd("/Users/criseldabautista/Documents/summer sessions")
#Import your libraries
library(ggtree)
library(rgdal)
library(ggplot2)
sequence_data<-read.csv("PH_figures/sequence_data.csv")
lineage_info<-read.csv("PH_figures/relevant_lineages.csv")
new_lineage<-read.csv("PH_figures/new_lineages.csv")
tree<-ape::read.tree("PH_figures/Ph_designation.fasta.align.contree")
#Run this next line ONLY if your 'lineage_info' table in R has 7 columns:
lineage_info<-lineage_info[,-c(1)]
#This combines the new and relevant lineages into one table
lineage_info<-rbind(lineage_info, new_lineage)
#Selecting a list of colours ready to use
lineage_info$colour<-NA
Colours<-c("Reds","Purples","YlOrBr","PuBuGn","YlOrRd","OrRd","PuBu","Pastel1","Greens","Greys",
"GnBu","BuGn","RdPu","Oranges","BuPu","YlGn","PuRd","YlGnBu")
#Extracting the subclades from the lineage (e.g. Cosmopolitan AF1b, Cosmopolitan AF1a)
lineages<-data.frame(lineage = lineage_info$lineage, subclade = NA)
for (i in 1:length(lineages$lineage)) {
lineages$subclade[i]<-strsplit(lineages$lineage[i], "_")[[1]][1]
}
letters <- c("A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1", "I1", "J1", "K1", "L1", "M1", "N1",
"O1", "P1", "Q1", "R1", "S1", "T1", "U1", "V1", "W1", "X1", "Y1", "Z1")
if(length(grep("_", lineage_info$lineage)) != 0) {
if (length(which(lineages$subclade %in% letters)) != 0) {
lineages<-lineages[-c(which(lineages$subclade %in% letters)),]
}
}
#Assigning a colour group to each subclade (e.g. Purple may be AF1b) then giving each lineage a unique colour
# within the subclade colour group (e.g. AF1b_A1 = dark purple, AF1b_A1.1 = light purple)
clades<-unique(lineages$subclade)
lineage<-lineage_info$lineage[-c(grep("_", lineage_info$lineage))]
cols<-RColorBrewer::brewer.pal(9, "Blues")
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[-c(grep("_", lineage_info$lineage))]<-pal
for (i in 1:length(clades)) {
lineage<-grep(clades[i], lineage_info$lineage)
cols<-RColorBrewer::brewer.pal(3, Colours[i])
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[(grep(clades[i], lineage_info$lineage))]<-pal
}
attach(sequence_data)
lineage_info<-lineage_info[order(lineage_info$lineage),]
#Making a nice tree with tips colours according to lineage, outlined in grey for aesthetics
plot_tree<-ggtree::ggtree(tree, colour = "grey50", ladderize = T) %<+% sequence_data +
geom_tiplab()+
ggtree::geom_tippoint(color="grey50", size=4)+
ggtree::geom_tippoint(ggplot2::aes(color=lineage), size=3)  +
ggtree::theme(plot.title = ggplot2::element_text(size = 40, face = "bold"))+
ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
#View the tree!
plot_tree
#Adding a bar along the side to show lineage colours/positions
genotype<-data.frame(lineage = sequence_data$lineage)
rownames(genotype)<-sequence_data$ID
plot_tree<-ggtree::gheatmap(plot_tree, genotype, offset=-0.01, width=.1, font.size=3, color = NA,
colnames_angle=-45, hjust=0) +
ggtree::scale_fill_manual(values=c(lineage_info$colour), name="lineage")+
ggtree::theme(legend.position = "none")
#View the tree!
plot_tree
#Save the tree!
ggsave("PH_figures/tree.png", plot = plot_tree)
#Identify which essential ancestral lineages aren't included in your dataset - for this we'll add them by hand!
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
write.csv(lineage_info, "PH_figures/test.csv", row.names = F)
#When you've corrected the lineage file, reimport it!
lineage_info<-read.csv("PH_figures/test.csv")
#Check there aren't any more missing evolutionary lineages (except the overall clade)
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
#If there are none - make the sunburst!
sunburst<-plotly::plot_ly(
labels = c(lineage_info$lineage),
parents = c(lineage_info$parent),
values = c(lineage_info$n_seqs),
type = "sunburst",
marker = list(colors = (lineage_info$colour))
)
#View the sunburst
sunburst
#Save the sunburst as an interactive html!
htmlwidgets::saveWidget(plotly::as_widget(sunburst), "PH_figures/sunburst.html")
#Import your shapefile
shape_district<-readOGR("PH_figures/Shapefiles/PHLsmallTEST_fixed.shp")
#Plot a map of your shapefile
plot<-
ggplot() +
geom_polygon(data = shape_district, aes( x = long, y = lat, group = group), fill="grey80", color="white") +
theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
#Import your metadata with the lat/long info
metadata<-read.csv("PH_figures/metadata_PH.csv")
#If you haven't already, add the lineage info to the metadata (mine doesn't need this - so don't run this if
# you're using mine as an example!)
metadata$lineage<-NA
for (i in 1:length(metadata$ID)) {
metadata$lineage[i]<-sequence_data$lineage[which(sequence_data$ID == metadata$ID[i])]
}
#Add the lineage colour info to the metadata so everything stays the same colour scheme
metadata$colour<-NA
for (i in 1:length(metadata$ID)) {
metadata$colour[i]<-lineage_info$colour[which(lineage_info$lineage == metadata$lineage[i])]
}
#Add your data to the overall country plot
country_plot<-plot +
geom_point(data = metadata, aes(x = longitude, y = latitude), size = 2,
shape = 23, fill = metadata$colour)
#View the plot. It can take some time to appear!
country_plot
#Save the plot
ggsave("PH_figures/country_plot.png",
plot = country_plot)
#We can zoom in on specific areas of interest by adding coordinate limits to our country plot:
zoom<-country_plot+
coord_sf(xlim = c(120.0,124), ylim=c(12.0,19.0))
#See the plot
zoom
#Save the plot
ggsave("PH_figures/zoom_plot.png",
plot = zoom)
rm(list=ls())
setwd("/Users/criseldabautista/Documents/summer sessions")
#Import your libraries
library(ggtree)
library(rgdal)
library(ggplot2)
sequence_data<-read.csv("PH_figures/sequence_data.csv")
lineage_info<-read.csv("PH_figures/relevant_lineages.csv")
new_lineage<-read.csv("PH_figures/new_lineages.csv")
tree<-ape::read.tree("PH_figures/Ph_designation.fasta.align.contree")
#Run this next line ONLY if your 'lineage_info' table in R has 7 columns:
lineage_info<-lineage_info[,-c(1)]
#This combines the new and relevant lineages into one table
lineage_info<-rbind(lineage_info, new_lineage)
#Selecting a list of colours ready to use
lineage_info$colour<-NA
Colours<-c("Reds","Purples","YlOrBr","PuBuGn","YlOrRd","OrRd","PuBu","Pastel1","Greens","Greys",
"GnBu","BuGn","RdPu","Oranges","BuPu","YlGn","PuRd","YlGnBu")
#Extracting the subclades from the lineage (e.g. Cosmopolitan AF1b, Cosmopolitan AF1a)
lineages<-data.frame(lineage = lineage_info$lineage, subclade = NA)
for (i in 1:length(lineages$lineage)) {
lineages$subclade[i]<-strsplit(lineages$lineage[i], "_")[[1]][1]
}
letters <- c("A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1", "I1", "J1", "K1", "L1", "M1", "N1",
"O1", "P1", "Q1", "R1", "S1", "T1", "U1", "V1", "W1", "X1", "Y1", "Z1")
if(length(grep("_", lineage_info$lineage)) != 0) {
if (length(which(lineages$subclade %in% letters)) != 0) {
lineages<-lineages[-c(which(lineages$subclade %in% letters)),]
}
}
#Assigning a colour group to each subclade (e.g. Purple may be AF1b) then giving each lineage a unique colour
# within the subclade colour group (e.g. AF1b_A1 = dark purple, AF1b_A1.1 = light purple)
clades<-unique(lineages$subclade)
lineage<-lineage_info$lineage[-c(grep("_", lineage_info$lineage))]
cols<-RColorBrewer::brewer.pal(9, "Blues")
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[-c(grep("_", lineage_info$lineage))]<-pal
for (i in 1:length(clades)) {
lineage<-grep(clades[i], lineage_info$lineage)
cols<-RColorBrewer::brewer.pal(3, Colours[i])
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[(grep(clades[i], lineage_info$lineage))]<-pal
}
attach(sequence_data)
attach(sequence_data)
lineage_info<-lineage_info[order(lineage_info$lineage),]
#Making a nice tree with tips colours according to lineage, outlined in grey for aesthetics
plot_tree<-ggtree::ggtree(tree, colour = "grey50", ladderize = T) %<+% sequence_data +
ggtree::geom_tippoint(color="grey50", size=4)+
ggtree::geom_tippoint(ggplot2::aes(color=lineage), size=3)  +
ggtree::theme(plot.title = ggplot2::element_text(size = 40, face = "bold"))+
ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
#Adding a bar along the side to show lineage colours/positions
genotype<-data.frame(lineage = sequence_data$lineage)
rownames(genotype)<-sequence_data$ID
plot_tree<-ggtree::gheatmap(plot_tree, genotype, offset=-0.01, width=.1, font.size=3, color = NA,
colnames_angle=-45, hjust=0) +
ggtree::scale_fill_manual(values=c(lineage_info$colour), name="lineage")+
ggtree::theme(legend.position = "none")
#View the tree!
plot_tree
#Save the tree!
ggsave("PH_figures/tree.png", plot = plot_tree)
#Identify which essential ancestral lineages aren't included in your dataset - for this we'll add them by hand!
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
write.csv(lineage_info, "PH_figures/test.csv", row.names = F)
#When you've corrected the lineage file, reimport it!
lineage_info<-read.csv("PH_figures/test.csv")
#Save the tree!
ggsave("PH_figures/tree.png", plot = plot_tree)
#Identify which essential ancestral lineages aren't included in your dataset - for this we'll add them by hand!
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
write.csv(lineage_info, "PH_figures/test.csv", row.names = F)
#When you've corrected the lineage file, reimport it!
lineage_info<-read.csv("PH_figures/test.csv")
#Check there aren't any more missing evolutionary lineages (except the overall clade)
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
#If there are none - make the sunburst!
sunburst<-plotly::plot_ly(
labels = c(lineage_info$lineage),
parents = c(lineage_info$parent),
values = c(lineage_info$n_seqs),
type = "sunburst",
marker = list(colors = (lineage_info$colour))
)
#View the sunburst
sunburst
#Save the sunburst as an interactive html!
htmlwidgets::saveWidget(plotly::as_widget(sunburst), "PH_figures/sunburst.html")
#Import your shapefile
shape_district<-readOGR("PH_figures/Shapefiles/PHLsmallTEST_fixed.shp")
#Plot a map of your shapefile
plot<-
ggplot() +
geom_polygon(data = shape_district, aes( x = long, y = lat, group = group), fill="grey80", color="white") +
theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
#Import your metadata with the lat/long info
metadata<-read.csv("PH_figures/metadata_PH.csv")
#If you haven't already, add the lineage info to the metadata (mine doesn't need this - so don't run this if
# you're using mine as an example!)
metadata$lineage<-NA
for (i in 1:length(metadata$ID)) {
metadata$lineage[i]<-sequence_data$lineage[which(sequence_data$ID == metadata$ID[i])]
}
#Add the lineage colour info to the metadata so everything stays the same colour scheme
metadata$colour<-NA
for (i in 1:length(metadata$ID)) {
metadata$colour[i]<-lineage_info$colour[which(lineage_info$lineage == metadata$lineage[i])]
}
#Add your data to the overall country plot
country_plot<-plot +
geom_point(data = metadata, aes(x = longitude, y = latitude), size = 2,
shape = 23, fill = metadata$colour)
#View the plot. It can take some time to appear!
country_plot
#Save the plot
ggsave("PH_figures/country_plot.png",
plot = country_plot)
#We can zoom in on specific areas of interest by adding coordinate limits to our country plot:
zoom<-country_plot+
coord_sf(xlim = c(120.0,124), ylim=c(12.0,19.0))
#See the plot
zoom
#Save the plot
ggsave("PH_figures/zoom_plot.png",
plot = zoom)
setwd("~/Documents/summer sessions/PH_figures")
library(dplyr)
library(ggplot2)
library(knitr)
sequence_data<-read.csv("sequence_data.csv")
rm(list=ls())
library(dplyr)
library(ggplot2)
library(knitr)
sequence_data<-read.csv("sequence_data.csv")
metadata<-read.csv("metadata_PH.csv")
relevant_lineages<-read.csv("relevant_lineages.csv")
new_lineages<-read.csv("new_lineages.csv")
path_sunburst<-("sunburst_html.png")
path_tree<-("tree.png")
path_country_map<-("country_plot.png")
cat(paste("This study contains ", length(sequence_data$ID), " sequences from between ", min(sequence_data$year), " and ", max(sequence_data$year), ".", sep = ""))
View(metadata)
cat(paste("This sequence data came from", length(unique(metadata$province)), "different provinces. "))
cat(paste("This sequence data came from", length(unique(metadata$municipality)), "different municipalities. "))
View(metadata)
cat(paste("This study contains ", length(sequence_data$ID), " sequences from between ", min(sequence_data$year), " and ", max(sequence_data$year), ".", sep = ""))
cat(paste("This sequence data came from", length(unique(metadata$place)), "different places. "))
regions<-data.frame(region=unique(metadata$province), count=NA)
for (i in 1:length(regions$region)) {
regions$count[i]<-length(which(metadata$province == regions$region[i]))
}
for (i in 1:length(regions$region)) {
regions$count[i]<-length(which(metadata$place == regions$region[i]))
}
regions<-data.frame(region=unique(metadata$place), count=NA)
for (i in 1:length(regions$region)) {
regions$count[i]<-length(which(metadata$place == regions$region[i]))
}
names(regions)<-c("Province", "Number of Sequences")
kable(regions, row.names=F)
cat(paste("This sequence data came from", length(unique(metadata$species)), "different hosts. "))
hosts<-data.frame(host=unique(metadata$species), count=NA)
for (i in 1:length(hosts$host)) {
hosts$count[i]<-length(which(metadata$species == hosts$host[i]))
}
cat(paste(round(((hosts$count[grep("Canis familiaris", hosts$host)])/sum(hosts$count))*100, digits = 2)), "% of these are from dogs.", sep = "")
names(hosts)<-c("Host", "Number of Sequences")
kable(hosts, row.names=F)
ggplot(sequence_data, aes(x = lineage, fill = species)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
View(sequence_data)
ggplot(metadata, aes(x = lineage, fill = species)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
cat(paste(length(unique(sequence_data$lineage)), "lineages have been detected in this study.", (length(relevant_lineages$lineage)+length(new_lineages$lineage)) - length(unique(sequence_data$lineage)), "lineages are included here that have not been seen in this study, but are direct parents of lineages in this study, so are included for relevant evolutionary investigations."))
View(sequence_data)
length(unique(sequence_data$lineage))
cat(paste("There are ", length(relevant_lineages$lineage), " existing lineages relevant to this study."))
kable(relevant_lineages[,-c(1,7)], row.names=F)
if(length(new_lineages) != 0) {
cat(paste("There are ", length(new_lineages$lineage), " new lineages identified in this dataset."))
kable(new_lineages[,-c(6)], row.names=F)
} else {
cat(paste("There are no new lineages identified in this dataset."))
}
cat(paste("The sequences span ", as.integer(max(sequence_data$year)) - as.integer(min(sequence_data$year)), " years from ", min(sequence_data$year), " to ", max(sequence_data$year),". ", sep = ""))
library(dplyr)
library(ggplot2)
library(knitr)
sequence_data<-read.csv("sequence_data.csv")
metadata<-read.csv("metadata_PH.csv")
relevant_lineages<-read.csv("relevant_lineages.csv")
new_lineages<-read.csv("new_lineages.csv")
path_sunburst<-("sunburst_html.png")
path_tree<-("tree.png")
path_country_map<-("country_plot.png")
h1, h2{
text-align: center;
font-family: Helvetica;
font-weight: bold;
}
body{
margin-top: 75px;
font-family: Helvetica;
font-weight: lighter;
font-size: 14pt;
}
cat(paste("This study contains ", length(sequence_data$ID), " sequences from between ", min(sequence_data$year), " and ", max(sequence_data$year), ".", sep = ""))
View(metadata)
View(sequence_data)
library(dplyr)
library(ggplot2)
library(knitr)
sequence_data<-read.csv("sequence_data.csv")
metadata<-read.csv("metadata_PH.csv")
relevant_lineages<-read.csv("relevant_lineages.csv")
new_lineages<-read.csv("new_lineages.csv")
path_sunburst<-("sunburst_html.png")
path_tree<-("tree.png")
path_country_map<-("country_plot.png")
cat(paste("This study contains ", length(sequence_data$ID), " sequences from between ", min(sequence_data$year), " and ", max(sequence_data$year), ".", sep = ""))
cat(paste("This sequence data came from", length(unique(metadata$place)), "different places. "))
regions<-data.frame(region=unique(metadata$place), count=NA)
for (i in 1:length(regions$region)) {
regions$count[i]<-length(which(metadata$place == regions$region[i]))
}
names(regions)<-c("Province", "Number of Sequences")
kable(regions, row.names=F)
kable(regions, row.names=F)
cat(paste("This sequence data came from", length(unique(metadata$species)), "different hosts. "))
hosts<-data.frame(host=unique(metadata$species), count=NA)
for (i in 1:length(hosts$host)) {
hosts$count[i]<-length(which(metadata$species == hosts$host[i]))
}
cat(paste(round(((hosts$count[grep("Canis familiaris", hosts$host)])/sum(hosts$count))*100, digits = 2)), "% of these are from dogs.", sep = "")
names(hosts)<-c("Host", "Number of Sequences")
kable(hosts, row.names=F)
kable(hosts, row.names=F)
<strong>**Table 3.** Numbers of sequences from different hosts. </strong>
```{r hosts, echo=FALSE, warning=FALSE, message=FALSE, results='asis'}
ggplot(metadata, aes(x = lineage, fill = species)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
cat(paste(length(unique(sequence_data$lineage)), "lineages have been detected in this study.", (length(relevant_lineages$lineage)+length(new_lineages$lineage)) - length(unique(sequence_data$lineage)), "lineages are included here that have not been seen in this study, but are direct parents of lineages in this study, so are included for relevant evolutionary investigations."))
cat(paste("There are ", length(relevant_lineages$lineage), " existing lineages relevant to this study."))
kable(relevant_lineages[,-c(1,7)], row.names=F)
if(length(new_lineages) != 0) {
cat(paste("There are ", length(new_lineages$lineage), " new lineages identified in this dataset."))
kable(new_lineages[,-c(6)], row.names=F)
} else {
cat(paste("There are no new lineages identified in this dataset."))
}
cat(paste("The sequences span ", as.integer(max(sequence_data$year)) - as.integer(min(sequence_data$year)), " years from ", min(sequence_data$year), " to ", max(sequence_data$year),". ", sep = ""))
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
cat(paste("The year with the greatest number of sequences is ", getmode(sequence_data$year), " with ", length(which(sequence_data$year == getmode(sequence_data$year))), " sequences."))
cat(paste("The most prevalent lineage is ", getmode(sequence_data$lineage), " with ", length(which(sequence_data$lineage == getmode(sequence_data$lineage))), " sequences."))
data_sub<-sequence_data
graph<-ggplot(data_sub, aes(x = year, fill = lineage)) +
geom_bar() + theme(legend.position = "bottom") + theme(axis.text.x = element_text(size = 7)) +
theme(legend.position="none") +
theme(axis.title.x=element_blank())
lin<-data.frame(table(data_sub$lineage))
names(lin)<-c("lineage", "count")
pie<-ggplot(lin, aes(x="", y=count, fill=lineage)) +
geom_bar(stat="identity", width=1, color="white") +
coord_polar("y", start=0) +
theme_void()+   theme(legend.position="right") + theme(legend.text = element_text(size=7)) +theme(legend.key.size = unit(0.45,"cm"))+theme(legend.title = element_blank())
gridExtra::grid.arrange(graph,pie)
rm(list=ls())
setwd("~/Documents/GitHub/MADDOG_CTB/Phil_Seq_data/Phil_sequences")
#Import your libraries
library(ggtree)
library(rgdal)
library(ggplot2)
sequence_data<-read.csv("Phil_designation/Outputs/sequence_data.csv")
lineage_info<-read.csv("Phil_designation/Outputs/relevant_lineages.csv")
new_lineage<-read.csv("Phil_designation/Outputs/new_lineages.csv")
tree<-ape::read.tree("Phil_designation/Trees/Phil_designation_combined_aligned.fasta.contree")
#This combines the new and relevant lineages into one table
lineage_info<-rbind(lineage_info, new_lineage)
#Selecting a list of colours ready to use
lineage_info$colour<-NA
Colours<-c("Reds","Purples","YlOrBr","PuBuGn","YlOrRd","OrRd","PuBu","Pastel1","Greens","Greys",
"GnBu","BuGn","RdPu","Oranges","BuPu","YlGn","PuRd","YlGnBu")
#Extracting the subclades from the lineage (e.g. Cosmopolitan AF1b, Cosmopolitan AF1a)
lineages<-data.frame(lineage = lineage_info$lineage, subclade = NA)
for (i in 1:length(lineages$lineage)) {
lineages$subclade[i]<-strsplit(lineages$lineage[i], "_")[[1]][1]
}
letters <- c("A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1", "I1", "J1", "K1", "L1", "M1", "N1",
"O1", "P1", "Q1", "R1", "S1", "T1", "U1", "V1", "W1", "X1", "Y1", "Z1")
if(length(grep("_", lineage_info$lineage)) != 0) {
if (length(which(lineages$subclade %in% letters)) != 0) {
lineages<-lineages[-c(which(lineages$subclade %in% letters)),]
}
}
#Assigning a colour group to each subclade (e.g. Purple may be AF1b) then giving each lineage a unique colour
# within the subclade colour group (e.g. AF1b_A1 = dark purple, AF1b_A1.1 = light purple)
clades<-unique(lineages$subclade)
lineage<-lineage_info$lineage[-c(grep("_", lineage_info$lineage))]
cols<-RColorBrewer::brewer.pal(9, "Blues")
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[-c(grep("_", lineage_info$lineage))]<-pal
for (i in 1:length(clades)) {
lineage<-grep(clades[i], lineage_info$lineage)
cols<-RColorBrewer::brewer.pal(3, Colours[i])
pal<-colorRampPalette(c(cols))
pal<-rev(pal(length(lineage)))
lineage_info$colour[(grep(clades[i], lineage_info$lineage))]<-pal
}
attach(sequence_data)
lineage_info<-lineage_info[order(lineage_info$lineage),]
#Making a nice tree with tips colours according to lineage, outlined in grey for aesthetics
plot_tree<-ggtree::ggtree(tree, colour = "grey50", ladderize = T) %<+% sequence_data +
ggtree::geom_tippoint(color="grey50", size=4)+
ggtree::geom_tippoint(ggplot2::aes(color=lineage), size=3)  +
ggtree::theme(plot.title = ggplot2::element_text(size = 40, face = "bold"))+
ggtree::scale_color_manual(values=c(lineage_info$colour)) +
ggtree::theme(legend.position = "none")
#Adding a bar along the side to show lineage colours/positions
genotype<-data.frame(lineage = sequence_data$lineage)
rownames(genotype)<-sequence_data$ID
plot_tree<-ggtree::gheatmap(plot_tree, genotype, offset=-0.01, width=.1, font.size=3, color = NA,
colnames_angle=-45, hjust=0) +
ggtree::scale_fill_manual(values=c(lineage_info$colour), name="lineage")+
ggtree::theme(legend.position = "none")
#View the tree!
plot_tree
#Save the tree!
ggsave("PH_figures/tree.png", plot = plot_tree)
#Identify which essential ancestral lineages aren't included in your dataset - for this we'll add them by hand!
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
#When you've corrected the lineage file, reimport it!
lineage_info<-read.csv("PH_figures/test.csv")
#Check there aren't any more missing evolutionary lineages (except the overall clade)
'%notin%'<-Negate("%in%")
lineage_info$parent[which(lineage_info$parent %notin% lineage_info$lineage)]
#If there are none - make the sunburst!
sunburst<-plotly::plot_ly(
labels = c(lineage_info$lineage),
parents = c(lineage_info$parent),
values = c(lineage_info$n_seqs),
type = "sunburst",
marker = list(colors = (lineage_info$colour))
)
#View the sunburst
sunburst
#Save the sunburst as an interactive html!
htmlwidgets::saveWidget(plotly::as_widget(sunburst), "sunburst.html")
